

// This relates to burstcoin and BHD, which mine by demonstrating storage capacity.
// The network capacity is many orders of magnitude larger than petabytes.
// Meanwhile, other networks like siacoin, have excess capacity.
// Since cryptocurrency is inhibited, for some time there is a space where the capcaity
// of one netowrk could be used to make money on another.
// There are many similar spaces.  This one is near.

#define _FILE_OFFSET_BITS 64
#include <cstdint>

struct nonce
{
	struct scoop {
		uint8_t hash_a[32];
		// in POC2, hash_b is swapped with that of the mirror scoop index2=4095-index1
		uint8_t hash_b[32];
	};
	struct scoop scoops[4096];
};

// each value is a 64-bit number, _not_ zero-prefixed
// POC1 filename: AccountID_StartingNonce_NrOfNonces_Stagger [stagger is nonces per group]
// POC2 filename: AccountID_StartingNonce_NrOfNonces
// 	the data is just a sequence of scoops: all the scoop 0s in nonce order,
// 	  then all scoop 1s in nonce order, etc
//
// For sequential reading, the most optimal way to store a plot file is with an entire
// drive as a single file.

extern "C" {

// from libShabal's autogenerated header file.  some of the file has errors, so just pasted in

/// Creates a single PoC Nonce.
///
/// `plot_buffer` must be correct size - no size checks are performed.
void create_plot(uint64_t account_id,
                 uint64_t nonce,
                 uint8_t poc_version,
                 uint8_t *plot_buffer,
                 uintptr_t plot_buffer_offset);

}

#include <siaskynet_multiportal.hpp>
#include <cassert>

#include "skystream.hpp"

class BufferedSkystream : public skystream
{
public:
	BufferedSkystream(sia::skynet_multiportal & multiportal)
	:skystream(multiportal) {start();}
	BufferedSkystream(nlohmann::json identifiers, sia::skynet_multiportal & multiportal)
	:skystream(identifiers, multiportal) {start();}

	BufferedSkystream(BufferedSkystream const &) = default;
	BufferedSkystream(BufferedSkystream &&) = default;

	~BufferedSkystream()
	{
		shutdown();
	}

	void shutdown()
	{
		{
			std::lock_guard<std::mutex> lock(mutex);
			if (!pumping) {
				return;
			}
			pumping = false;
		}
		threadup.join();
		threaddown.join();
	}

	uint64_t size()
	{
		std::lock_guard<std::mutex> lock(mutex);
		return offsetup;
	}
	uint64_t backlog()
	{
		std::lock_guard<std::mutex> lock(mutex);
		return queueup.size();
	}
	uint64_t uploadedsize()
	{
		std::lock_guard<std::mutex> lock(mutex);
		return offsetup - queueup.size();
	}
	void basictipmetadata(nlohmann::json & identifiers, uint64_t & uploaded, uint64_t & total)
	{
		std::lock_guard<std::mutex> lock(mutex);
		identifiers = skystream::identifiers();
		total = offsetup;
		uploaded = total - queueup.size();
	}

	void append(std::vector<uint8_t> && data)
	{
		std::lock_guard<std::mutex> lock(mutex);
		queueup.insert(queueup.end(), data.begin(), data.end());
		moredataup.notify_all();
	}

	std::vector<uint8_t> read(double offset)
	{
		std::unique_lock<std::mutex> lock(mutex);
		reading.notify_all();
		offsetdown = offset;
		queuedown.clear();
		moredatadown.wait(lock, [&]() {
			return !pumping || queuedown.size() != 0;
		});
		std::vector<uint8_t> data = std::move(queuedown);
		return data;
	}
	void doneread()
	{
		std::lock_guard<std::mutex> lock(mutex);
		offsetdown = -1;
		queuedown.clear();
	}

	std::mutex mutex;
	std::condition_variable uploaded; // notified when the size increases

private:
	std::condition_variable reading;
	void start()
	{
		std::lock_guard<std::mutex> lock(mutex);
		offsetup = span("bytes").second;
		offsetdown = -1;
		threadup = std::thread(&BufferedSkystream::pumpup, this);
		threadup.detach();
		threaddown = std::thread(&BufferedSkystream::pumpdown, this);
		threaddown.detach();
	}
	void pumpup()
	{
		while ("pumploop") {
			std::vector<uint8_t> data;

			{
				std::unique_lock<std::mutex> lock(mutex);
				moredataup.wait(lock, [&]() {
					return !pumping || queueup.size() != 0;
				});
				if (!pumping && queueup.size() == 0) {
					uploaded.notify_all();
					return;
				}
				data = std::move(queueup);
			}
			if (data.size()) {
				write(data, "bytes", offsetup);
				offsetup += data.size();
				{
					std::lock_guard<std::mutex> lock(mutex);
					uploaded.notify_all();
				}
			}
		}
	}

	void pumpdown()
	{
		ssize_t offset = -1;
		while ("pumploop") {
			std::vector<uint8_t> data;
			{
				std::unique_lock<std::mutex> lock(mutex);
				if (offset == -1) {
					reading.wait(lock);
				}
				offset = offsetdown;
				if  (!pumping) {
					moredatadown.notify_all();
					return;
				}
			}
			if (offset != -1) {
				auto data = skystream::read("bytes", offset);
				if (data.size()) {
					std::lock_guard<std::mutex> lock(mutex);
					offset += data.size();
					queuedown.insert(queuedown.end(), data.begin(), data.end());
					offsetdown = offset;
					moredatadown.notify_all();
				} else {
					std::lock_guard<std::mutex> lock(mutex);
					offsetdown = offset = -1;
				}
			} 
		}
	}

	bool pumping = true;
	std::thread threadup;
	std::thread threaddown;
	std::condition_variable moredataup;
	std::condition_variable moredatadown;
	std::vector<uint8_t> queueup;
	std::vector<uint8_t> queuedown;
	size_t offsetup;
	size_t offsetdown;
};

class Plotfile
{
public:
	Plotfile(uint64_t account)
	: account(account), metastream(multiportal)
	{
		std::cerr << "Readying scoop pumps ..." << std::endl;
		while (scoops.size() < sizeof(nonce::scoops) / sizeof(nonce::scoop)) {
			metadata["scoopstreams"][scoops.size()] = nullptr;
			scoops.emplace_back(new BufferedSkystream(multiportal));
			std::cerr << scoops.size() << "/" << sizeof(nonce::scoops) / sizeof(nonce::scoop) << "\r" << std::flush;
		}
		start();
	}
	Plotfile(uint64_t account, nlohmann::json identifiers)
	: account(account), metastream(identifiers, multiportal), _identifiers(identifiers)
	{
		auto data = metastream.read("index", metastream.span("index").second);
		std::string str(data.begin(), data.end());
		metadata = nlohmann::json::parse(str);
		std::cerr << "Found metadata document. " << std::endl;
		std::cerr << "Readying scoop pumps ..." << std::endl;
		for (auto & identifiers :metadata["scoopstreams"]) {
			scoops.emplace_back(new BufferedSkystream(multiportal));
			std::cerr << scoops.size() << "/" << sizeof(nonce::scoops) / sizeof(nonce::scoop) << "\r" << std::flush;
		}
		start();
	}

	int64_t filename_to_noncecount(std::string name)
	{
		auto pos1 = name.find_first_of('_');
		auto pos2 = name.find_first_of('_', pos1);
		if (pos2 == std::string::npos || pos1 == std::string::npos) {
			return -1;
		}
		try {
			uint64_t account = std::stoull(name.substr(0, pos1));
			uint64_t startingnonce = std::stoull(name.substr(pos1+1, pos2-pos1 - 1));
			uint64_t noncecount = std::stoull(name.substr(pos2+1,name.size()-pos2-1));
			if (startingnonce != 0 || account != this->account) {
				return -1;
			}
			if (noncecount > this->noncecount()) {
				return -1;
			}
			return noncecount;
		} catch(...) {
			return -1;
		}
	}

	std::string filename()
	{
		return std::to_string(account) + "_0_" + std::to_string(noncecount());
	}

	nlohmann::json identifiers()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return _identifiers;
	}

	uint64_t noncecount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return depth;
	}

	size_t readscoops(uint8_t * buf, uint64_t noncecount, size_t offset, size_t size)
	{
		constexpr uint64_t scoopcount = sizeof(nonce::scoops) / sizeof(nonce::scoop);
		// noncecount shows total filesize
		// scoop id is within offset
		uint64_t scoopssize = noncecount * sizeof(nonce) / scoopcount;
		uint64_t scoopsindex = offset / scoopssize;
		offset -= scoopsindex * scoopssize;
		if (scoopsindex != lastscoopread) {
			scoops[lastscoopread]->doneread();
			lastscoopread = scoopsindex;
		}
		auto data = scoops[scoopsindex]->read(offset);
		if (data.size() > size) {
			data.resize(size);
		}
		std::copy(data.begin(), data.end(), buf);
		return data.size();
	}

	void shutdown()
	{
		if (stoppedcount() == 0) {
			incrementstoppedcount();
			scoopsthread.join();
			metadatathread.join();
		}
	}

	uint64_t const account;

private:
	void start()
	{
		scoopsthread = std::thread(&Plotfile::sendplot, this);
		metadatathread = std::thread(&Plotfile::scribeplot, this);
		lastscoopread = 0;
	}
	void sendplot()
	{
		std::cerr << "Beginning plot generation thread ..." << std::endl;
		uint64_t depthup;
		{
			std::lock_guard<std::mutex> guard(mutex);
			depthup = this->depth;
		}
		nonce plotbit;
		while (stoppedcount() == 0) {
			// generate 1 nonce, and append all scoops to stream
			create_plot(account, depthup, 2, (uint8_t*)&plotbit, 0);
			
			// convert to scoops
			for (size_t index = 0; index < sizeof(plotbit.scoops) / sizeof(nonce::scoop); ++ index) {
				auto & scoop = plotbit.scoops[index];
				std::vector<uint8_t> data;
				data.resize(sizeof(nonce::scoop));
				std::copy((char*)&scoop,(char*)(&scoop+1),data.data());
				assert(scoops[index]->size() == depthup * data.size());
				// scoops bounds should all have the right index
				scoops[index]->append(std::move(data));
			}
			++ depthup;
		}
		// wait for all scoops to send
		for (auto & scoop : scoops) {
			scoop->shutdown();
		}
		incrementstoppedcount();
	}
	void scribeplot()
	{
		std::cerr << "Beginning plot consolidation thread ..." << std::endl;
		int64_t lastminimum = depth;
		while (stoppedcount() < 2) {
			int64_t minimum = -1;
			size_t minimumindex;
			for (size_t index = 0; index < scoops.size(); ++ index) {
				nlohmann::json identifiers;
				uint64_t uploaded, total;
				scoops[index]->basictipmetadata(identifiers, uploaded, total);
				metadata["scoopstreams"][index] = identifiers;
				if (uploaded < minimum || minimum == -1) {
					minimum = uploaded;
					minimumindex = index;
				}
			}
			if (minimum > lastminimum) {
				std::cerr << "Stored new noncecount of " << minimum << "." << std::endl;
				lastminimum = minimum;
				std::vector<uint8_t> data;
				{
					std::lock_guard<std::mutex> guard(mutex);
					depth = minimum;
					std::string datastr = metadata.dump();
					data.insert(data.end(), datastr.begin(), datastr.end());
				}
				metastream.write(data, "bytes", metastream.span("bytes").second);
				{
					std::lock_guard<std::mutex> guard(mutex);
					_identifiers = metastream.identifiers();
				}
			} else {
				std::unique_lock<std::mutex> lock(scoops[minimumindex]->mutex);
				scoops[minimumindex]->uploaded.wait(lock);
			}
		}
	}
	// skystream:
	// .get(json identifiers) // returns a std::vector<uint8_t> for identifires["skylink"]
	// .identifiers() // get identifiers for stream
	// .block_span(std::string span, double offset) // return a pair of bounds around offset
	// .span(string span) // return a pair of bounds for span
	// .write(vector data, string span, double offset) // write to stream, offset should be end of span
	// .read(string span, double offset, string flow = "real") // read from stream, returns vector
	// spans are "bytes", "time", "index"
	// so we could write to nonces or scoops
	sia::skynet_multiportal multiportal;
	skystream metastream;
	nlohmann::json metadata;
	std::vector<std::unique_ptr<BufferedSkystream>> scoops;

	std::thread metadatathread;
	std::thread scoopsthread;
	ssize_t lastscoopread;

	std::mutex mutex;
	int _stoppedcount;
	uint64_t depth;
	nlohmann::json _identifiers;
	int stoppedcount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return _stoppedcount;
	}
	void incrementstoppedcount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		++ _stoppedcount;
	}
	
};

#define FUSE_USE_VERSION 34
#include "Fusepp/Fuse.cpp"


#include <fstream>
#include <sstream>
#include <cstdio> // for rename
#include <cstring>  // for strerror, handling rename's return
class PlotFS : public Fusepp::Fuse<PlotFS>
{
public:
	PlotFS(std::string configfilename)
	{
		PlotFS::configfilename = configfilename;
		uint64_t account = std::stoull(configfilename);
		std::cerr << "Opening config file " << configfilename << " ..." << std::endl;
		std::ifstream configfile(configfilename);
		if (configfile.is_open()) {
			std::ostringstream configstrm;
			configstrm << configfile.rdbuf();
			std::string configstr = configstrm.str();

			std::cerr << "Resuming plotting for account id " << account << " ..." << std::endl;
			plotfile = new Plotfile(account,nlohmann::json::parse(configstr));
			lastnoncecount = plotfile->noncecount();
		} else {
			std::cerr << " ... failed.  Will write file after starting to plot." << std::endl;
			std::cerr << "Initiating plotting for account id " << account << " ..." << std::endl;
			plotfile = new Plotfile(account);
			updateconfig();
		}
	}
	~PlotFS()
	{
		plotfile->shutdown();
		updateconfig();
		delete plotfile;
	}
	static void updateconfig()
	{
		auto noncecount = plotfile->noncecount();
		if (noncecount == lastnoncecount) {
			return;
		}
		std::cerr << "Writing " << configfilename << " with " << noncecount << " nonces ..." << std::endl;
		lastnoncecount = noncecount;
		std::istringstream configstrm(plotfile->identifiers().dump());
		std::string tempfile = configfilename + "_update";
		std::ofstream configfile(tempfile);
		configfile << configstrm.rdbuf();
		configfile.close();
		int result = std::rename(tempfile.c_str(), configfilename.c_str());
		if (result != 0) {
			throw std::runtime_error(strerror(result));
		}
	}
	static int getattr(const char *path, struct stat *stbuf, struct fuse_file_info *)
	{
		memset(stbuf, 0, sizeof(struct stat));
		if (path[0] == '/' && path[1] == 0) {
			stbuf->st_mode = S_IFDIR | 0755;
			stbuf->st_nlink = 2;
			return 0;
		}
		if (path[0] != '/') {
			return -ENOENT;
		}
		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = noncecount * sizeof(nonce);
		return 0;
	}
	static int readdir(const char *path, void*buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi, enum fuse_readdir_flags)
	{
		if (path[0] != '/' || path[1] != 0) {
			return -ENOENT;
		}
	
		filler(buf, ".", NULL, 0, FUSE_FILL_DIR_PLUS);
		filler(buf, "..", NULL, 0, FUSE_FILL_DIR_PLUS);
		std::string filename = plotfile->filename();
		filler(buf, filename.c_str(), NULL, 0, FUSE_FILL_DIR_PLUS);
		updateconfig();
	
		return 0;
	}
	static int open(const char *path, struct fuse_file_info *fi)
	{
		if ((fi->flags & 3) != O_RDONLY) {
			return -EACCES;
		}

		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
		updateconfig();
	
		return 0;
	}
	static int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi)
	{
		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
	
		return plotfile->readscoops((uint8_t*)buf, noncecount, offset, size);
	}
	// PlotFS is hacky because Fusepp is incomplete
	static Plotfile * plotfile;
	static uint64_t lastnoncecount;
	static std::string configfilename;
};
Plotfile * PlotFS::plotfile;
uint64_t PlotFS::lastnoncecount;
std::string PlotFS::configfilename;

int main(int argc, char **argv)
{
	if (argc<2) {
		std::cout << "Provide <accountnum>.json as first argument." << std::endl;
		return -1;
	}
	PlotFS plotfs(argv[1]);
	plotfs.run(argc-1, argv+1);
}
