

// This relates to burstcoin and BHD, which mine by demonstrating storage capacity.
// The network capacity is many orders of magnitude larger than petabytes.
// Meanwhile, other networks like siacoin, have excess capacity.
// Since cryptocurrency is inhibited, for some time there is a space where the capcaity
// of one netowrk could be used to make money on another.
// There are many similar spaces.  This one is near.

#define _FILE_OFFSET_BITS 64
#include <cstdint>

struct nonce
{
	struct scoop {
		uint8_t hash_a[32];
		// in POC2, hash_b is swapped with that of the mirror scoop index2=4095-index1
		uint8_t hash_b[32];
	};
	struct scoop scoops[4096];
};
constexpr unsigned NUMSCOOPS = sizeof(nonce::scoops) / sizeof(nonce::scoop);

// each value is a 64-bit number, _not_ zero-prefixed
// POC1 filename: AccountID_StartingNonce_NrOfNonces_Stagger [stagger is nonces per group]
// POC2 filename: AccountID_StartingNonce_NrOfNonces
// 	the data is just a sequence of scoops: all the scoop 0s in nonce order,
// 	  then all scoop 1s in nonce order, etc
//
// For sequential reading, the most optimal way to store a plot file is with an entire
// drive as a single file.

extern "C" {

// from libShabal's autogenerated header file.  some of the file has errors, so just pasted in

/// Creates a single PoC Nonce.
///
/// `plot_buffer` must be correct size - no size checks are performed.
void create_plot(uint64_t account_id,
                 uint64_t nonce,
                 uint8_t poc_version,
                 uint8_t *plot_buffer,
                 uintptr_t plot_buffer_offset);

}

#include <cassert>

#include "bufferedskystream.hpp"
#include "tools.hpp"

class Plotfile
{
public:
	Plotfile(uint64_t account, std::string filename)
	: account(account), _identifiers(file2json(filename)), metastream(portalpool, _identifiers), scoops(portalpool), identifiersfile(filename)
	{
		if (_identifiers.empty()) {
			std::cerr << "Readying scoop pumps ..." << std::endl;
			while (scoops.size() < NUMSCOOPS) {
				size_t index = scoops.add();
				metadata["scoopstreams"][index] = scoops.get(index).identifiers();
				std::cerr << scoops.size() << "/" << NUMSCOOPS << "\r" << std::flush;
			}
			_identifiers = metastream.identifiers();
			start();
		} else {
			double tailindex = metastream.span("index").second;
			auto data = metastream.read("index", tailindex);
			std::string str(data.begin(), data.end());
			metadata = nlohmann::json::parse(str);
			std::cerr << "Found metadata document. " << std::endl;
			std::cerr << "Readying scoop pumps ..." << std::endl;
			for (auto & identifiers : metadata["scoopstreams"]) {
				size_t index = scoops.add(identifiers);
				std::cerr << scoops.size() << "/" << NUMSCOOPS << "\r" << std::flush;
			}
		}
		start();
	}

	int64_t filename_to_noncecount(std::string name)
	{
		auto pos1 = name.find_first_of('_');
		auto pos2 = name.find_first_of('_', pos1);
		if (pos2 == std::string::npos || pos1 == std::string::npos) {
			return -1;
		}
		try {
			uint64_t account = std::stoull(name.substr(0, pos1));
			uint64_t startingnonce = std::stoull(name.substr(pos1+1, pos2-pos1 - 1));
			uint64_t noncecount = std::stoull(name.substr(pos2+1,name.size()-pos2-1));
			if (startingnonce != 0 || account != this->account) {
				return -1;
			}
			if (noncecount > this->noncecount()) {
				return -1;
			}
			return noncecount;
		} catch(...) {
			return -1;
		}
	}

	std::string filename()
	{
		return std::to_string(account) + "_0_" + std::to_string(noncecount());
	}

	nlohmann::json identifiers()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return _identifiers;
	}

	uint64_t noncecount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return depth;
	}

	size_t readscoops(uint8_t * buf, uint64_t noncecount, size_t offset, size_t size)
	{
		constexpr uint64_t scoopcount = sizeof(nonce::scoops) / sizeof(nonce::scoop);
		// noncecount shows total filesize
		// scoop id is within offset
		uint64_t scoopssize = noncecount * sizeof(nonce) / scoopcount;
		uint64_t scoopsindex = offset / scoopssize;
		offset -= scoopsindex * scoopssize;
		if (scoopsindex != lastscoopread) {
			scoops.get(lastscoopread).xfer_local_down(0,0,0);
			lastscoopread = scoopsindex;
		}
		auto data = scoops.get(scoopsindex).xfer_local_down(offset, size);
		std::copy(data.begin(), data.end(), buf);
		return data.size();
	}

	void shutdown()
	{
		if (stoppedcount() == 0) {
			incrementstoppedcount();
			scoops.shutdown();
			scoopsthread.join();
			//metadatathread.join();
		}
	}

	uint64_t const account;

private:
	void start()
	{
		// first discern our depth
		depth = -1;
		for (size_t index = 0; index < scoops.size(); ++ index) {
			auto & scoop = scoops.get(index);
			int64_t thisdepth = scoop.processedup() / sizeof(nonce::scoop);
			if (depth == -1 || thisdepth < depth) {
				depth = thisdepth;
				scoopsonlyatdepth = 1;
			} else if (thisdepth == depth) {
				++ scoopsonlyatdepth;
			}
		}
		std::cerr << "Starting noncecount is " << depth << std::endl;

		scoopsthread = std::thread(&Plotfile::sendplot, this);
		//metadatathread = std::thread(&Plotfile::scribeplot, this);
		scoops.set_up_callback(std::bind(&Plotfile::scribeplot, this, std::placeholders::_1, std::placeholders::_2));
		lastscoopread = 0;
	}
	void sendplot()
	{
		std::cerr << "Beginning plot generation thread ..." << std::endl;
		uint64_t depthup;
		{
			std::lock_guard<std::mutex> guard(mutex);
			depthup = this->depth;
		}
		nonce plotbit;
		while (stoppedcount() == 0) {
			// generate 1 nonce, and append all scoops to stream
			create_plot(account, depthup, 2, (uint8_t*)&plotbit, 0);
			
			// convert to scoops
			for (size_t index = 0; index < sizeof(plotbit.scoops) / sizeof(nonce::scoop); ++ index) {
				auto & scoop = plotbit.scoops[index];
				std::vector<uint8_t> data;
				data.resize(sizeof(nonce::scoop));
				std::copy((char*)&scoop,(char*)(&scoop+1),data.data());
				assert(scoops.get(index).sizeup() == depthup * data.size());
				// scoops bounds should all have the right index
				scoops.get(index).queue_local_up(std::move(data));
			}
			++ depthup;
		}
	}
	void scribeplot(bufferedskystream& lastscoop, uint64_t lastsize)
	{
		// REVIWING FOR BUFFEREDSKYSTREAMS
		// this looks like the first thing in need of modification
		// i'm suspecting it sohuld turn into an upload callback.

		// rewrote this to function as a callback but believe there was a logical error
		// oh no i think it works!  it's just kinda obscure.  scoops sets up a pump that pumps the stream most in need.
		// we keep them all the same, so the shortest ones are pumped.  it unfortunately relise on internal behavior.
		// but it has the advantage right now of testing that behavior.

		nlohmann::json identifiers;
		uint64_t uploaded, total;
		lastscoop.basictipmetadata(identifiers, uploaded, total);
		metadata["scoopstreams"][lastscoop.index] = identifiers;
		uint64_t scoopdepth = uploaded / sizeof(nonce::scoop);
		assert(scoopdepth > depth);
		-- scoopsonlyatdepth;

		std::cerr << "Extended scoop " << lastscoop.index << " to " << scoopdepth << " nonces: " << scoopsonlyatdepth << " scoops remain." << std::endl;

		assert(scoopsonlyatdepth >= 0);
		if (scoopsonlyatdepth == 0) {
			scoopdepth = depth;
			for (size_t index = 0; index < scoops.size(); ++ index) {
				auto & scoop = scoops.get(index);
				int64_t thisdepth = scoop.processedup() / sizeof(nonce::scoop);
				if (scoopdepth == depth || thisdepth < scoopdepth) {
					scoopdepth = thisdepth;
					scoopsonlyatdepth = 1;
				} else if (scoopdepth == thisdepth) {
					++ scoopsonlyatdepth;
				}
			}
			assert(scoopdepth > depth);

			std::cerr << "Updating plotfile to " << scoopdepth << " nonces.  " << scoopsonlyatdepth << " scoops must be extended next." << std::endl;
			std::string metadatastr;
			{
				std::lock_guard<std::mutex> guard(mutex);
				this->depth = scoopdepth;
				metadatastr = metadata.dump();
			}
			std::vector<uint8_t> metadatabytes(metadatastr.begin(), metadatastr.end());
			// later, maybe use portalpool with metastream
			metastream.write(metadatabytes, "bytes", metastream.span("bytes").second);
			{
				std::lock_guard<std::mutex> guard(mutex);
				_identifiers = metastream.identifiers();
				json2file(_identifiers, identifiersfile);
			}
			std::cerr << "New noncecount: " << depth << std::endl;
		}

		// this function used to wait on the uploaded cv of the minimum stream.  we didn't know and had two approaches to rewrite, and picked the callback one so that data would be stored immediately after upload; a decision-making metric used in other logging projects.  likely the metric can be merged with other approaches; we need the norm of preserving data, and timestamps are part of data.
	}
	// skystream:
	// .get(json identifiers) // returns a std::vector<uint8_t> for identifires["skylink"]
	// .identifiers() // get identifiers for stream
	// .block_span(std::string span, double offset) // return a pair of bounds around offset
	// .span(string span) // return a pair of bounds for span
	// .write(vector data, string span, double offset) // write to stream, offset should be end of span
	// .read(string span, double offset, string flow = "real") // read from stream, returns vector
	// spans are "bytes", "time", "index"
	// so we could write to nonces or scoops
	sia::portalpool portalpool;
	nlohmann::json _identifiers;
	skystream metastream;
	nlohmann::json metadata;
	std::string identifiersfile;
	bufferedskystreams scoops;

	std::thread metadatathread;
	std::thread scoopsthread;
	ssize_t lastscoopread;

	std::mutex mutex;
	int _stoppedcount;
	int64_t depth;
	uint64_t scoopsonlyatdepth;
	int stoppedcount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		return _stoppedcount;
	}
	void incrementstoppedcount()
	{
		std::lock_guard<std::mutex> guard(mutex);
		++ _stoppedcount;
	}
	
};

//#define FUSE_USE_VERSION 34
#include "Fusepp/Fuse.cpp"


#include <fstream>
#include <sstream>
#include <cstdio> // for rename
#include <cstring>  // for strerror, handling rename's return
class PlotFS : public Fusepp::Fuse<PlotFS>
{
public:
	PlotFS(std::string configfilename)
	{
		PlotFS::configfilename = configfilename;
		uint64_t account = std::stoull(configfilename);
		std::cerr << "Opening config file " << configfilename << " ..." << std::endl;
		/*
		std::ifstream configfile(configfilename);
		if (configfile.is_open()) {
			std::ostringstream configstrm;
			configstrm << configfile.rdbuf();
			std::string configstr = configstrm.str();

			std::cerr << "Resuming plotting for account id " << account << " ..." << std::endl;
			plotfile = new Plotfile(account,nlohmann::json::parse(configstr));
			lastnoncecount = plotfile->noncecount();
		} else {
			std::cerr << " ... failed.  Will write file after starting to plot." << std::endl;
			std::cerr << "Initiating plotting for account id " << account << " ..." << std::endl;
			plotfile = new Plotfile(account);
			updateconfig();
		}
		*/
		plotfile = new Plotfile(account, configfilename);
	}
	~PlotFS()
	{
		plotfile->shutdown();
		//updateconfig();
		delete plotfile;
	}
	/*
	static void updateconfig()
	{
		auto noncecount = plotfile->noncecount();
		if (noncecount == lastnoncecount) {
			return;
		}
		std::cerr << "Writing " << configfilename << " with " << noncecount << " nonces ..." << std::endl;
		lastnoncecount = noncecount;
		std::istringstream configstrm(plotfile->identifiers().dump());
		std::string tempfile = configfilename + "_update";
		std::ofstream configfile(tempfile);
		configfile << configstrm.rdbuf();
		configfile.close();
		int result = std::rename(tempfile.c_str(), configfilename.c_str());
		if (result != 0) {
			throw std::runtime_error(strerror(result));
		}
	}
	*/
	static int getattr(const char *path, struct stat *stbuf, struct fuse_file_info *)
	{
		memset(stbuf, 0, sizeof(struct stat));
		if (path[0] == '/' && path[1] == 0) {
			stbuf->st_mode = S_IFDIR | 0755;
			stbuf->st_nlink = 2;
			return 0;
		}
		if (path[0] != '/') {
			return -ENOENT;
		}
		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
		stbuf->st_mode = S_IFREG | 0444;
		stbuf->st_nlink = 1;
		stbuf->st_size = noncecount * sizeof(nonce);
		return 0;
	}
	static int readdir(const char *path, void*buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi, enum fuse_readdir_flags)
	{
		if (path[0] != '/' || path[1] != 0) {
			return -ENOENT;
		}
	
		filler(buf, ".", NULL, 0, FUSE_FILL_DIR_PLUS);
		filler(buf, "..", NULL, 0, FUSE_FILL_DIR_PLUS);
		std::string filename = plotfile->filename();
		filler(buf, filename.c_str(), NULL, 0, FUSE_FILL_DIR_PLUS);
		//updateconfig();
	
		return 0;
	}
	static int open(const char *path, struct fuse_file_info *fi)
	{
		if ((fi->flags & 3) != O_RDONLY) {
			return -EACCES;
		}

		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
		//updateconfig();
	
		return 0;
	}
	static int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi)
	{
		auto noncecount = plotfile->filename_to_noncecount(path + 1);
		if (noncecount == -1) {
			return -ENOENT;
		}
	
		return plotfile->readscoops((uint8_t*)buf, noncecount, offset, size);
	}
	// PlotFS is hacky because Fusepp is incomplete
	static Plotfile * plotfile;
	static uint64_t lastnoncecount;
	static std::string configfilename;
};
Plotfile * PlotFS::plotfile;
uint64_t PlotFS::lastnoncecount;
std::string PlotFS::configfilename;

int main(int argc, char **argv)
{
	if (argc<2) {
		std::cout << "Provide <accountnum>.json as first argument." << std::endl;
		return -1;
	}
	PlotFS plotfs(argv[1]);
	plotfs.run(argc-1, argv+1);
}
