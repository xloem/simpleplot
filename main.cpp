

// This relates to burstcoin and BHD, which mine by demonstrating storage capacity.
// The network capacity is many orders of magnitude larger than petabytes.
// Meanwhile, other networks like siacoin, have excess capacity.
// Since cryptocurrency is inhibited, for some time there is a space where the capcaity
// of one netowrk could be used to make money on another.
// There are many similar spaces.  This one is near.

#define _FILE_OFFSET_BITS 64
#include <cstdint>

struct nonce
{
	struct scoop {
		uint8_t hash_a[32];
		// in POC2, hash_b is swapped with that of the mirror scoop index2=4095-index1
		uint8_t hash_b[32];
	};
	struct scoop scoops[4096];
};

// each value is a 64-bit number, _not_ zero-prefixed
// POC1 filename: AccountID_StartingNonce_NrOfNonces_Stagger [stagger is nonces per group]
// POC2 filename: AccountID_StartingNonce_NrOfNonces
// 	the data is just a sequence of scoops: all the scoop 0s in nonce order,
// 	  then all scoop 1s in nonce order, etc
//
// For sequential reading, the most optimal way to store a plot file is with an entire
// drive as a single file.

extern "C" {

// from libShabal's autogenerated header file.  some of the file has errors, so just pasted in

/// Creates a single PoC Nonce.
///
/// `plot_buffer` must be correct size - no size checks are performed.
void create_plot(uint64_t account_id,
                 uint64_t nonce,
                 uint8_t poc_version,
                 uint8_t *plot_buffer,
                 uintptr_t plot_buffer_offset);

}

/// Creates PoC Nonces, with SIMD instructions for extra speed.
///
/// `plot_buffer` must be correct size - no size checks are performed.
///
/// `nonce_count` counts from 1 - 0 is no plots and will do nothing.
void create_plots(uint64_t account_id,
                  uint64_t start_nonce,
                  uint64_t nonce_count,
                  uint8_t poc_version,
                  uint8_t *plot_buffer,
                  uintptr_t plot_buffer_offset);

#include <string>

void write_plotfile(uint64_t acct, uint64_t start, uint64_t count, std::string * filename = 0)
{
	uint64_t size = count * sizeof(nonce);
}

uint64_t write_plotfile_bybytes(uint64_t acct, uint64_t start, uint64_t size, std::string * filename = 0)
{
	uint64_t count = size / sizeof(nonce);
	write_plotfile(acct, start, count, filename);
	return start + count;
}

#include <siaskynet_multiportal.hpp>
#include <cassert>

#include "skystream.hpp"

class BufferedSkystream : public skystream
{
public:
	BufferedSkystream(sia::skynet_multiportal & multiportal)
	:skystream(multiportal) {start();}
	BufferedSkystream(nlohmann::json identifiers, sia::skynet_multiportal & multiportal)
	:skystream(identifiers, multiportal) {start();}

	~BufferedSkystream()
	{
		std::lock_guard<std::mutex> lock(queue_mutex);
		pumping = false;
		thread.join();
	}

	uint64_t size()
	{
		return offset;
	}
	uint64_t backlog()
	{
		std::lock_guard<std::mutex> lock(queue_mutex);
		return queue.size();
	}
	uint64_t uploadedsize()
	{
		return size() - backlog();
	}

	void append(std::vector<uint8_t> && data)
	{
		std::lock_guard<std::mutex> lock(queue_mutex);
		queue.insert(data.begin(), data.end(), queue.end());
		moredata.notify_all();
	}

private:
	void start()
	{
		std::lock_guard<std::mutex> lock(queue_mutex);
		offset = span("bytes").second;
		thread = std::thread(&pump, *this);
		thread.detach();
	}
	void pump()
	{
		while ("pumploop") {
			std::vector<uint8_t> data;

			{
				std::lock_guard<std::mutex> lock(queue_mutex);
				moredata.wait_for(queuemutex, 0, [&] {
					return pumping && queue.size() == 0;
				});
				data = std::move(queue);
			}
			if (data.size()) {
				write(data, "bytes", offset);
				offset += data.size();
			}
			if (!pumping) {
				return;
			}
		}
	}

	bool pumping = true;
	std::thread thread;
	std::mutex queuemutex;
	std::condition_variable moredata;
	std::vector<uint8_t> queue;
	size_t offset;
};

class Plotfile
{
public:
	Plotfile(account, nlohmann::json metadata = {})
	: account(account), metadata(metadata), metastream(multiportal)
	{
		if (!metadata.contains("depth")) {
			metadata["depth"] = 0;
		}
		plot();
	}

private:
	void plot()
	{
		nonce plotbit;
		create_plot(account, metadata["depth"], 2, &plotbit, 0);
		
		// generate 1 nonce, and append all scoops to stream
	}
	// skystream:
	// .get(json identifiers) // returns a std::vector<uint8_t> for identifires["skylink"]
	// .identifiers() // get identifiers for stream
	// .block_span(std::string span, double offset) // return a pair of bounds around offset
	// .span(string span) // return a pair of bounds for span
	// .write(vector data, string span, double offset) // write to stream, offset should be end of span
	// .read(string span, double offset, string flow = "real") // read from stream, returns vector
	// spans are "bytes", "time", "index", or others made up
	// so we could write to nonces or scoops
	uint64_t account;
	sia::skynet_multiportal multiportal;
	skystream metastream;
	std::vector<BufferedSkystream> scoops;
	nlohmann::json metadata;
};

class Generator
{
public:
	static Generator * single;

	// data is made of streams of scoops
	// streams of scoops are made from streams of nonces
	// each nonce has another set of scoops in it.

	Generator(std::string url, uint64_t blocksize=1024*1024*1)
	: blocksize(blocksize), url("sia://" + url)
	{
		assert(single == 0);
		single = this;

		std::cout << url << std::endl;

		try {
			spot = queryspot(url);
		} catch (std::runtime_error const & fetcherror) {
			spot.depth = 0;
			try {
				spot.account = std::stoull(url);
			} catch(std::invalid_argument & converterror) {
				throw fetcherror;
			}
			for(int i = 0; i < sizeof(spot.parallel_link); ++i){
				spot.parallel_link[i] = ' ';
			}
			newplot();
		}

	}

	uint64_t blocksize;

	std::string filenameforspot(endpoint spot, size_t size)
	{
		return std::to_string(spot.account) + "_" + std::to_string(spot.depth) + "_" + std::to_string(spot.count);
	}

	void newplot()
	{
		std::cout << "Plotting ..." << std::endl;
		std::vector<uint8_t> newplot;
		endpoint newspot = spot;
		newspot.count = blocksize;
		newplot.resize(blocksize + sizeof(newspot));
		uint64_t count = blocksize / sizeof(nonce);
		create_plots(spot.account, newspot.depth, newspot.count, 2, newplot.data(), 0);
		std::cout << "Uploading " << newplot.size() << " bytes ..." << std::endl;
		std::copy((char*)&newspot, (char*)(&newspot+1), newplot.data() + blocksize);
		newspot.depth += newspot.count;
		std::string link = put(std::move(newplot));
		std::copy(link.data() + link.size() - sizeof(spot.parallel_link), link.data() + link.size(), spot.parallel_link);
		std::cout << std::string(spot.parallel_link, spot.parallel_link+sizeof(spot.parallel_link)) << std::endl;

		spot = newspot;
			// moves wrong way
			// as we get more
	}

	struct endpoint
	{
		uint64_t account;
		uint64_t depth;
		uint64_t count;
		char parallel_link[46];
	} spot;
	std::string url;

	endpoint queryspot(std::string url)
	{
		auto xfer = portal.begin_transfer(sia::skynet_multiportal::transfer_kind::download);
		sia::skynet skynet(xfer.portal);
		auto query = skynet.query(url, std::chrono::milliseconds(1000));
		std::vector<uint8_t> data = skynet.download(url, {{query.metadata.len - sizeof(endpoint), query.metadata.len}}, std::chrono::milliseconds(10000)).data;
		endpoint spot;
		std::copy(data.begin(), data.end(), (char*)&spot);
		
		portal.end_transfer(xfer, sizeof(spot) + sizeof(query));
		return spot;
	}

	std::vector<uint8_t> get(std::string url)
	{
		auto xfer = portal.begin_transfer(sia::skynet_multiportal::transfer_kind::download);
		std::vector<uint8_t> result;
		try {
			sia::skynet portal(xfer.portal);
			result = portal.download(url, {}, std::chrono::milliseconds(1000)).data;
		} catch(...) {
			portal.end_transfer(xfer, 0);
			throw;
		}
		portal.end_transfer(xfer, result.size());
		return result;
	}

	std::string put(std::vector<uint8_t> const & data)
	{
		auto xfer = portal.begin_transfer(sia::skynet_multiportal::transfer_kind::upload);
		std::string result;
		try {
			sia::skynet portal(xfer.portal);
			result = portal.upload({"",data,""}, std::chrono::milliseconds(120000));
		} catch(...) {
			portal.end_transfer(xfer, 0);
			throw;
		}
		portal.end_transfer(xfer, data.size());
		return result;
	}

	std::string filename()
	{
		return "/hellofilename";
	}

	uint64_t filesize()
	{
		return 5;
	}

	uint64_t filedata(uint8_t * buffer, uint64_t offset, uint64_t len)
	{
		std::string demodata = "hello";
		if (len > demodata.size()) { len = demodata.size(); }
		std::copy(demodata.begin(), demodata.end(), buffer);
		return len;
	}

	sia::skynet_multiportal portal;
};
Generator * Generator::single = 0;

#include "Fusepp/Fuse.cpp"


class PlotFS : public Fusepp::Fuse<PlotFS>
{
public:
	static int getattr(const char *path, struct stat *stbuf, struct fuse_file_info *)
	{
		int res = 0;

		memset(stbuf, 0, sizeof(struct stat));
		if (path[0] == '/' && path[1] == 0) {
			stbuf->st_mode = S_IFDIR | 0755;
			stbuf->st_nlink = 2;
		} else if (path == Generator::single->filename()) {
			stbuf->st_mode = S_IFREG | 0444;
			stbuf->st_nlink = 1;
			stbuf->st_size = Generator::single->filesize();
		} else
			res = -ENOENT;
	
		return res;
	}
	static int readdir(const char *path, void*buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi, enum fuse_readdir_flags)
	{
		if (path[0] != '/' || path[1] != 0) {
			return -ENOENT;
		}
	
		filler(buf, ".", NULL, 0, FUSE_FILL_DIR_PLUS);
		filler(buf, "..", NULL, 0, FUSE_FILL_DIR_PLUS);
		auto fn = Generator::single->filename();
		filler(buf, fn.c_str() + 1, NULL, 0, FUSE_FILL_DIR_PLUS);
	
		return 0;
	}
	static int open(const char *path, struct fuse_file_info *fi)
	{
		if (path != Generator::single->filename())
			return -ENOENT;
	
		if ((fi->flags & 3) != O_RDONLY)
			return -EACCES;
	
		return 0;
	}
	static int read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi)
	{
		if (path != Generator::single->filename())
			return -ENOENT;
	
		return Generator::single->filedata((uint8_t*)buf, offset, size);
	}
};

int main(int argc, char **argv)
{
	if (argc==1) {
		return -1;
	}
	Generator generator(argv[1]);
	PlotFS plotfs;
	plotfs.run(argc-1, argv+1);
}
